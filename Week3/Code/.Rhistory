Tree_height_vector <- vector()
distance_vector[1]
angle_degrees_vector[1]
for (z in 1:120){
Tree_height_vector <- c(Tree_height_vector,TreeHeight(distance_vector[z],angle_degrees_vector[z]))
}
Tree_height_vector
cbind(MyData,Tree_height_vector)
MyData <- read.csv('../Data/trees.csv', header = TRUE)
print(MyData)
distance_vector <- vector()
for (i in MyData[2]){
distance_vector <- c(i)
}
print(length(distance_vector)) #figure out how many distnace measurements were taken and transfer to a vector
angle_degrees_vector <- vector()
for (y in MyData[3]){
angle_degrees_vector <- c(y)
}
print(length(angle_degrees_vector)) #count angle degrees measurements and put them in a vector
TreeHeight <- function(degrees, distance){
radians <- degrees * pi / 180
height <- distance * tan(radians)
#print(paste("Tree height is:", height))
return (height)
}
Tree_height.m <- vector()
distance_vector[1]
angle_degrees_vector[1]
for (z in 1:120){
Tree_height.m <- c(Tree_height.m,TreeHeight(distance_vector[z],angle_degrees_vector[z]))
}
cbind(MyData,Tree_height.m)
MyData <- read.csv('../Data/trees.csv', header = TRUE)
print(MyData)
distance_vector <- vector()
for (i in MyData[2]){
distance_vector <- c(i)
}
print(length(distance_vector)) #figure out how many distnace measurements were taken and transfer to a vector
angle_degrees_vector <- vector()
for (y in MyData[3]){
angle_degrees_vector <- c(y)
}
print(length(angle_degrees_vector)) #count angle degrees measurements and put them in a vector
TreeHeight <- function(degrees, distance){
radians <- degrees * pi / 180
height <- distance * tan(radians)
#print(paste("Tree height is:", height))
return (height)
}
Tree_height.m <- vector()
distance_vector[1]
angle_degrees_vector[1]
for (z in 1:120){
Tree_height.m <- c(Tree_height.m,TreeHeight(distance_vector[z],angle_degrees_vector[z]))
}
cbind(MyData,Tree_height.m)
write.csv(TreeHts.csv, "../Results/TreeHts.csv")
# This function calculates heights of trees given distance of each tree
# from its base and angle to its top, using  the trigonometric formula
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"
MyData <- read.csv('../Data/trees.csv', header = TRUE)
print(MyData)
distance_vector <- vector()
for (i in MyData[2]){
distance_vector <- c(i)
}
print(length(distance_vector)) #figure out how many distnace measurements were taken and transfer to a vector
angle_degrees_vector <- vector()
for (y in MyData[3]){
angle_degrees_vector <- c(y)
}
print(length(angle_degrees_vector)) #count angle degrees measurements and put them in a vector
TreeHeight <- function(degrees, distance){
radians <- degrees * pi / 180
height <- distance * tan(radians)
#print(paste("Tree height is:", height))
return (height)
}
Tree_height.m <- vector()
distance_vector[1]
angle_degrees_vector[1]
for (z in 1:120){
Tree_height.m <- c(Tree_height.m,TreeHeight(distance_vector[z],angle_degrees_vector[z]))
}
cbind(MyData,Tree_height.m)
write.csv(MyData, "../Results/TreeHts.csv")
# This function calculates heights of trees given distance of each tree
# from its base and angle to its top, using  the trigonometric formula
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"
MyData <- read.csv('../Data/trees.csv', header = TRUE)
print(MyData)
distance_vector <- vector()
for (i in MyData[2]){
distance_vector <- c(i)
}
print(length(distance_vector)) #figure out how many distnace measurements were taken and transfer to a vector
angle_degrees_vector <- vector()
for (y in MyData[3]){
angle_degrees_vector <- c(y)
}
print(length(angle_degrees_vector)) #count angle degrees measurements and put them in a vector
TreeHeight <- function(degrees, distance){
radians <- degrees * pi / 180
height <- distance * tan(radians)
#print(paste("Tree height is:", height))
return (height)
}
Tree_height.m <- vector()
distance_vector[1]
angle_degrees_vector[1]
for (z in 1:120){
Tree_height.m <- c(Tree_height.m,TreeHeight(distance_vector[z],angle_degrees_vector[z]))
}
MyData <- cbind(MyData,Tree_height.m)
write.csv(MyData, "../Results/TreeHts.csv")
M <- matrix(runif(1000000),1000,1000)
M
length(M)
dim(M)
M <- matrix(runif(1000000),1000,1000)
SumAllElements <- function(M){
Dimensions <- dim(M)
Tot <- 0
for (i in 1:Dimensions[1]){
for (j in 1:Dimensions[2]){
Tot <- Tot + M[i,j]
}
}
return (Tot)
}
print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))
SumAllElements <- function(M){
Dimensions <- dim(M)
Tot <- 0
for (i in 1:Dimensions[1]){
for (j in 1:Dimensions[2]){
Tot <- Tot + M[i,j]
}
}
return (Tot)
}
print(Tot)
print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))
TOt
Tot
SumAllElements <- function(M){
Dimensions <- dim(M)
Tot <- 0
for (i in 1:Dimensions[1]){
for (j in 1:Dimensions[2]){
Tot <- Tot + M[i,j]
}
}
print(Tot)
return (Tot)
}
M <- matrix(runif(1000000),1000,1000)
SumAllElements <- function(M){
Dimensions <- dim(M)
Tot <- 0
for (i in 1:Dimensions[1]){
for (j in 1:Dimensions[2]){
Tot <- Tot + M[i,j]
}
}
return (Tot)
}
print(Tot)
print(SumAllElements(M))
M <- matrix(runif(1000000),1000,1000)
SumAllElements <- function(M){
Dimensions <- dim(M)
Tot <- 0
for (i in 1:Dimensions[1]){
for (j in 1:Dimensions[2]){
Tot <- Tot + M[i,j]
}
}
return (Tot)
}
#print("Using loops, the time taken is:")
#rint(system.time(SumAllElements(M)))
print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
a <- NA
for (i in 1:10) {
a <- c(a, i)
print(a)
print(object.size(a))
}
a <- rep(NA, 10)
for (i in 1:10) {
a[i] <- i
print(a)
print(object.size(a))
}
b=rep(0,10)
b
a <- NA
Loop_one <- function(){
for (i in 1:10) {
a <- c(a, i)
print(a)
print(object.size(a))
}
a <- rep(NA, 10)
}
print(system.time(Loop_one(a)))
print(system.time(Loop_one()))
Loop_two <- function(){
for (i in 1:10) {
a[i] <- i
print(a)
print(object.size())
}
}
print(system.time(Loop_two()))
a <- rep(NA, 10)
Loop_two <- function(){
for (i in 1:10) {
a[i] <- i
print(a)
print(object.size())
}
}
print(system.time(Loop_two()))
a <- rep(NA, 10)
Loop_two <- function(){
for (i in 1:10) {
a[i] <- i
print(a)
print(object.size(a))
}
}
print(system.time(Loop_two()))
a <- NA
Loop_one <- function(){
for (i in 1:10) {
a <- c(a, i)
print(a)
print(object.size(a))
}
}
print(system.time(Loop_one()))
a <- NA
Loop_one <- function(){
for (i in 1:100) {
a <- c(a, i)
print(a)
print(object.size(a))
}
}
print(system.time(Loop_one()))
a <- rep(NA, 100)
Loop_two <- function(){
for (i in 1:100) {
a[i] <- i
print(a)
print(object.size(a))
}
}
print(system.time(Loop_two()))
a <- NA
Loop_one <- function(){
for (i in 1:100) {
a <- c(a, i)
print(a)
print(object.size(a))
}
}
print(system.time(Loop_one()))
a <- rep(NA, 100)
Loop_two <- function(){
for (i in 1:100) {
a[i] <- i
print(a)
print(object.size(a))
}
}
print(system.time(Loop_two()))
a <- NA
Loop_one <- function(){
for (i in 1:100) {
a <- c(a, i)
print(a)
print(object.size(a))
}
}
print(system.time(Loop_one()))
a <- rep(NA, 100)
Loop_two <- function(){
for (i in 1:100) {
a[i] <- i
print(a)
print(object.size(a))
}
}
print(system.time(Loop_two()))
a <- NA
Loop_one <- function(){
for (i in 1:100) {
a <- c(a, i)
#print(a)
#print(object.size(a))
}
}
print(system.time(Loop_one()))
a <- rep(NA, 100)
Loop_two <- function(){
for (i in 1:100) {
a[i] <- i
#print(a)
#print(object.size(a))
}
}
print(system.time(Loop_two()))
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)
## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print(RowMeans)
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)
## Take the mean of each row
RowMeans <- apply(M, 2, mean)
print(RowMeans)
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)
## Take the mean of each row
RowMeans <- apply(M, 3, mean)
print(RowMeans)
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)
## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print(RowMeans)
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)
## Take the mean of each row
RowMeans <- apply(M, c(1,1), mean)
print(RowMeans)
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)
## Take the mean of each row
RowMeans <- apply(M, c(2,2), mean)
print(RowMeans)
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)
## Take the mean of each row
RowMeans <- apply(M, 1) #margin indication: 1=row, 2=col, c(1,2)= row&col and FUN=mean which is the function to be applied
print(RowMeans)
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)
## Take the mean of each row
RowMeans <- apply(M, 1, mean) #margin indication: 1=row, 2=col, c(1,2)= row&col and FUN=mean which is the function to be applied
print(RowMeans)
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)
## Take the mean of each row
RowMeans <- apply(M, 1) #margin indication: 1=row, 2=col, c(1,2)= row&col and FUN=mean which is the function to be applied
print(RowMeans)
RowVars <- apply(M, 1, var)
print(RowVars)
ColMeans <- apply(M, 2, mean)
print(ColMeans)
M <- matrix(rnorm(100), 10, 10)
print(apply(M, 1, SomeOperation))
SomeOperation <- function(v){ # What does this function do
if (sum(v) > 0){
return(v * 100)
}
return (v)
}
print(apply(M, 1, SomeOperation))
myexperiment <- function(popn,n){
pop_sample <- sample(popn, n, replace=TRUE)
return(mean(pop_sample))
}
loopy_sample1 <- function(popn, n, num){
result1 <- vector() # Initialise empty vector of size 1
for (i in 1:num){
result1 <- c(result1, myexperiment(popn, n))
}
return (result1)
}
loopy_sample2 <- function(popn, n, num){
result2 <- vector( ,num) #Preallocate expected size
for (i in 1:num){
result2[i] <- myexperiment(popn, n)
}
return (result2)
}
x<-3
y<-vector( ,x)
y
x<-10
y<-vector( ,x)
y
loopy_sample3 <- function(popn, n, num){
result3 <- vector("list", num)
for (i in 1:num){
result3[[i]] <- myexperiment(popn, n)
}
return (result3)
}
sapply_sample <- function(popn, n, num){
result5 <- sapply(1:num, myexperiment(popn, n))
return(result5)
}
loopy_sample2 <- function(popn, n, num){
result2 <- vector( ,num) #Preallocate expected size
for (i in 1:num){
result2[i] <- myexperiment(popn, n)
}
return(result2)
}
loopy_sample2 <- function(popn, n, num){
result2 <- vector(,num) #Preallocate expected size
for (i in 1:num){
result2[i] <- myexperiment(popn, n)
}
return(result2)
}
loopy_sample2(10,100,1000)
popn <- rnorm(1000)
popn
hist(popn)
print("The loopy, non-preallocation approach takes:" )
print(system.time(loopy_sample1(popn, n, num)))
print("The loopy, but with preallocation approach takes:" )
print(system.time(loopy_sample2(popn, n, num)))
print("The loopy, non-preallocation approach takes:" )
print(system.time(loopy_sample3(popn, n, num)))
print("The vectorized sapply approach takes:" )
print(system.time(sapply_sample(popn, n, num)))
print("The vectorized lapply approach takes:" )
print(system.time(lapply_sample(popn, n, num)))
######### Functions ##########
## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn, n){
pop_sample <- sample(popn, n, replace=TRUE)
return(mean(pop_sample))
}
## Calculate means using a for loop without preallocation
loopy_sample1 <- function(popn, n, num){
result1 <- vector() # Initialise empty vector of size 1
for (i in 1:num){
result1 <- c(result1, myexperiment(popn, n))
}
return(result1)
}
## To run "num" iterations of the experiment using a for loop on a vector with preallocation
loopy_sample2 <- function(popn, n, num){
result2 <- vector( ,num) #Preallocate expected size
for (i in 1:num){
result2[i] <- myexperiment(popn, n)
}
return(result2)
}
## To run "num" iterations of the experiment using a for loop on a list with preallocation
loopy_sample3 <- function(popn, n, num){
result3 <- vector("list", num)
for (i in 1:num){
result3[[i]] <- myexperiment(popn, n)
}
return(result3)
}
## To run "num" iterations of the experiment using vectorization with lapply
lapply_sample <- function(popn, n, num){
result4 <- lapply(1:num, function(i) myexperiment(popn, n))
return(result4)
}
## To run "num" iterations of the experiment using vectorization with lapply
sapply_sample <- function(popn, n, num){
result5 <- sapply(1:num, function(i) myexperiment(popn, n))
return(result5)
}
popn <- rnorm(1000)
hist(popn)
n <- 20 # sample size for each experiment
num <- 1000 # Number of times to rerun the experiment
print("The loopy, non-preallocation approach takes:" )
print(system.time(loopy_sample1(popn, n, num)))
print("The loopy, but with preallocation approach takes:" )
print(system.time(loopy_sample2(popn, n, num)))
print("The loopy, non-preallocation approach takes:" )
print(system.time(loopy_sample3(popn, n, num)))
print("The vectorized sapply approach takes:" )
print(system.time(sapply_sample(popn, n, num)))
print("The vectorized lapply approach takes:" )
print(system.time(lapply_sample(popn, n, num)))
Tree_height.m <- vector()
