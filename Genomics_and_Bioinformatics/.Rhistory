ni_area <- st_polygon(list(cbind(x=c(-8.1, -6, -5, -6, -8.1), y=c(54.4, 56, 55, 54, 54.4))))
northern_ireland <- st_intersection(ireland, ni_area)
eire <- st_difference(ireland, ni_area) #difference of ireland from NI so removes NI
plot(eire)
# Combine the final geometries
uk_eire <- st_sfc(wales, england_no_london, scotland, london, northern_ireland, eire, crs=4326)
plot(uk_eire, asp=1)
# Make the UK into a single feature
uk_country <- st_union(uk_eire[-6]) #feature is a set of vector GIS geometries that represent a spatial unit we are interested in
print(uk_country) #[-6] gets rid of the 6th vector
print(uk_eire)
plot(uk_country, asp=1)
# Plot them
par(mfrow=c(1, 2), mar=c(3,3,1,1))
plot(uk_eire, asp=1, col=rainbow(6))
plot(st_geometry(uk_eire_capitals), add=TRUE) #adds captials to uk_eire
plot(uk_country, asp=1, col='lightblue')
# add features to vector geometries
uk_eire <- st_sf(name=c('Wales', 'England','Scotland', 'London',
'Northern Ireland', 'Eire'),
geometry=uk_eire) #st_sf creates sf which extends df with a sf column and can add attributes
plot(uk_eire, asp=1)
uk_eire$capital <- c('London', 'Edinburgh', 'Cardiff', NA, 'Belfast', 'Dublin')
uk_eire <- merge(uk_eire, pop_dens, by.x='name', by.y='country', all.x=TRUE)
print(uk_eire)
uk_eire_centroids <- st_centroid(uk_eire)
st_coordinates(uk_eire_centroids)
uk_eire$area <- st_area(uk_eire)
uk_eire$length <- st_length(uk_eire)
print(uk_eire)
plot(uk_eire[1], asp=1)
uk_eire$area <- set_units(uk_eire$area, 'km^2') # You can change units in a neat way
uk_eire$length <- set_units(uk_eire$length, 'km')
# will not allow errors in unit conversion
uk_eire$area <- set_units(uk_eire$area, 'kg')
#convert length to numeric
uk_eire$length <- as.numeric(uk_eire$length)
print(uk_eire)
st_distance(uk_eire)
st_distance(uk_eire_centroids)
plot(uk_eire['n_km2'], asp=1)
uk_eire$log_n_km2 <- log10(uk_eire$n_km2)
plot(uk_eire['log_n_km2'], asp=1)
plot(uk_eire['n_km2'], asp=1, logz=TRUE)
# British National Grid (EPSG:27700)
uk_eire_BNG <- st_transform(uk_eire, 27700)
st_bbox(uk_eire)
st_bbox(uk_eire_BNG)
# UTM50N (EPSG:32650)
uk_eire_UTM50N <- st_transform(uk_eire, 32650)
par(mfrow=c(1, 3), mar=c(3,3,1,1))
plot(st_geometry(uk_eire), asp=1, axes=TRUE, main='WGS 84')
plot(st_geometry(uk_eire_BNG), axes=TRUE, main='OSGB 1936 / BNG')
plot(st_geometry(uk_eire_UTM50N), axes=TRUE, main='UTM 50N')
# Set up some points separated by 1 degree latitude and longitude from St. Pauls
st_pauls <- st_sfc(st_pauls, crs=4326)
one_deg_west_pt <- st_sfc(st_pauls - c(1, 0), crs=4326) # near Goring
one_deg_north_pt <-  st_sfc(st_pauls + c(0, 1), crs=4326) # near Peterborough
st_distance(st_pauls, one_deg_west_pt)
st_distance(st_pauls, one_deg_north_pt)
st_distance(st_transform(st_pauls, 27700), st_transform(one_deg_west_pt, 27700))
#fix london
london_bng <- st_buffer(st_transform(st_pauls, 27700), 25000) #buffer creates separate polygon around features and transform changes crs
england_not_london_bng <- st_difference(st_transform(st_sfc(england, crs=4326), 27700), london_bng)
others_bng <- st_transform(st_sfc(eire, northern_ireland, scotland, wales, crs=4326), 27700)
corrected <- c(others_bng, london_bng, england_not_london_bng)
par(mar=c(3,3,1,1))
plot(corrected, main='25km radius London', axes=TRUE)
# Create an empty raster object covering UK and Eire
uk_raster_WGS84 <- raster(xmn=-11,  xmx=2,  ymn=49.5, ymx=59,
res=0.5, crs="+init=EPSG:4326")
hasValues(uk_raster_WGS84)
# Add data to the raster: just the number 1 to number of cells
values(uk_raster_WGS84) <- seq(length(uk_raster_WGS84))
par(mfrow=c(1,1))
plot(uk_raster_WGS84)
plot(st_geometry(uk_eire), add=TRUE, border='black', lwd=2, col='#FFFFFF44') #true adds existing vector data to existing map
m <- matrix(c(1, 1, 3, 3,
1, 2, 4, 3,
5, 5, 7, 8,
6, 6, 7, 7), ncol=4, byrow=TRUE)
square <- raster(m)
# Maximum values
square_agg_max <- aggregate(square, fact=2, fun=max)
values(square_agg_max)
# Average values
square_agg_mean <- aggregate(square, fact=2, fun=mean)
values(square_agg_mean)
# Modal values for categories
square_agg_modal <- aggregate(square, fact=2, fun=modal)
values(square_agg_modal) ## The bottom left cell has a modal value of 6 even though there is no mode: there are two 5s and two 6s. You can use `first` and `last` to specify which value gets chose but there is no mode.
# Copy parents
square_disagg <- disaggregate(square, fact=2)
# Interpolate
square_disagg_interp <- disaggregate(square, fact=2, method='bilinear')
# make two simple `sfc` objects containing points in  the
# lower left and top right of the two grids
uk_pts_WGS84 <- st_sfc(st_point(c(-11, 49.5)), st_point(c(2, 59)), crs=4326)
uk_pts_BNG <- st_sfc(st_point(c(-2e5, 0)), st_point(c(7e5, 1e6)), crs=27700)
#  Use st_make_grid to quickly create a polygon grid with the right cellsize
uk_grid_WGS84 <- st_make_grid(uk_pts_WGS84, cellsize=0.5)
uk_grid_BNG <- st_make_grid(uk_pts_BNG, cellsize=1e5)
# Reproject BNG grid into WGS84
uk_grid_BNG_as_WGS84 <- st_transform(uk_grid_BNG, 4326)
# Plot the features
plot(uk_grid_WGS84, asp=1, border='grey', xlim=c(-13,4))
plot(st_geometry(uk_eire), add=TRUE, border='darkgreen', lwd=2)
plot(uk_grid_BNG_as_WGS84, border='red', add=TRUE)
# Create the target raster
uk_raster_BNG <- raster(xmn=-200000, xmx=700000, ymn=0, ymx=1000000,
res=100000, crs='+init=EPSG:27700')
uk_raster_BNG_interp <- projectRaster(uk_raster_WGS84, uk_raster_BNG, method='bilinear')
uk_raster_BNG_ngb <- projectRaster(uk_raster_WGS84, uk_raster_BNG, method='ngb')
# compare the values in the top row
round(values(uk_raster_BNG_interp)[1:9], 2)
## [1]    NA 31.36 30.02 29.87 30.91 33.14 36.56 41.17    NA
values(uk_raster_BNG_ngb)[1:9]
## [1] NA 29 33 36 39 43 46 50 NA
par(mfrow=c(1,3), mar=c(1,1,2,1))
plot(uk_raster_BNG_interp, main='Interpolated', axes=FALSE, legend=FALSE)
plot(uk_raster_BNG_ngb, main='Nearest Neighbour',axes=FALSE, legend=FALSE)
rm(list=ls())
setwd("~/Documents/CMEECourseWork/Genomics_and_Bioinformatics")
myData <- read.csv("genomics_and_bioinformatics/Practicals/turtle.csv", header=FALSE, stringsAsFactors = FALSE, colClasses = c("character"))
myData[1:10,1:10]
myData[70:80,70:80]
myGenotypeData <- read.csv("genomics_and_bioinformatics/Practicals/turtle.genoytpes.csv", header=FALSE, stringsAsFactors = FALSE, colClasses = c("character"))
myGenotypeData <- read.csv("genomics_and_bioinformatics/Practicals/turtle.genotypes.csv", header=FALSE, stringsAsFactors = FALSE, colClasses = c("character"))
location_A <- matrix(0, nrow = 20, ncol = 2000, byrow = TRUE)
location_A
location_A <- myData[1:20,1:2000]
location_A
location_A[1:10,1:10]
myData[1:10,1:10]
location_B <- matrix(0, nrow = 20, ncol = 2000, byrow = TRUE)
location_C <- matrix(0, nrow = 20, ncol = 2000, byrow = TRUE)
location_D <- matrix(0, nrow = 20, ncol = 2000, byrow = TRUE)
location_B <- myData[21:40,1:2000]
myData[21:40,1:10]
location_B[1:20,1:10]
location_C <- myData[41:60,1:2000]
location_D <- myData[61:80,1:2000]
freq <- function(data){
counter <- 0
for (i in nrow(data)){
for (j in ncol(data)){
if (data[i,j]==1){
counter <- counter + 1
}
}
}
freq_1 <- counter/(nrow(data)*ncol(data))
freq_0 <- 1 - freq_0
return(freq_0,freq_1)
}
freq(location_A)
freq <- function(data){
counter <- 0
for (i in nrow(data)){
for (j in ncol(data)){
if (data[i,j]==1){
counter <- counter + 1
}
}
}
freq_1 <- counter/(nrow(data)*ncol(data))
freq_0 <- 1 - freq_1
return(freq_0,freq_1)
}
freq(location_A)
freq <- function(data){
freq_1 <- c()
freq_0 <- c()
counter <- 0
for (i in nrow(data)){
for (j in ncol(data)){
if (data[i,j]==1){
counter <- counter + 1
}
}
}
freq_1 <- counter/(nrow(data)*ncol(data))
freq_0 <- 1 - freq_1
return(c(freq_0,freq_1))
}
freq(location_A)
freq <- function(data){
freq_1 <- c()
counter <- 0
for (i in nrow(data)){
for (j in ncol(data)){
if (data[i,j]==1){
counter <- counter + 1
}
}
}
freq_1 <- counter/(nrow(data)*ncol(data))
return(freq_1)
}
freq(location_A)
location_A[1:10,1:10]
freq <- function(data){
freq_1 <- c()
for (i in ncol(data)){
if (length(unique(data[ ,i]))==2){
freq_1 <- c(freq_1,sum(data[ ,i])/(nrow(data)))
}
}
frequency_1 <- sum(freq_1)
return(frequency_1)
}
freq(location_A)
freq(location_A)
freq <- function(data){
freq_1 <- c()
for (i in ncol(data)){
if (length(unique(data[ ,i]))==2){
freq_1 <- c(freq_1,(sum(data[ ,i]))/(nrow(data)))
}
}
frequency_1 <- sum(freq_1)
return(frequency_1)
}
freq(location_A)
class(location_A)
location_A
location_A[1:10,1:10]
sum(location[1,1:10])
sum(location_A[1,1:10])
location_A <- matrix(0, nrow = 20, ncol = 2000, byrow = TRUE)
location_A <- myData[1:20,1:2000] #10 individuals in first location
myData <- as.matrix(read.csv("genomics_and_bioinformatics/Practicals/turtle.csv", header=FALSE, stringsAsFactors = FALSE, colClasses = c("numeric")))
location_A <- matrix(0, nrow = 20, ncol = 2000, byrow = TRUE)
location_A <- myData[1:20,1:2000] #10 individuals in first location
freq(location_A)
location_B <- matrix(0, nrow = 20, ncol = 2000, byrow = TRUE)
location_B <- myData[21:40,1:2000] #10 individuals in second location
location_C <- matrix(0, nrow = 20, ncol = 2000, byrow = TRUE)
location_C <- myData[41:60,1:2000] #10 individuals in third location
location_D <- matrix(0, nrow = 20, ncol = 2000, byrow = TRUE)
location_D <- myData[61:80,1:2000] #10 individuals in fourth location
freq_A <- freq(location_A)
freq_A
freq_B <- freq(location_B)
freq_B
freq_C <- freq(location_C)
freq_C
freq_D <- freq(location_D)
freq_D
location_A <- myData[1:20,1:2000] #10 individuals in first location
location_B <- myData[21:40,1:2000] #10 individuals in second location
location_C <- myData[41:60,1:2000] #10 individuals in third location
location_D <- myData[61:80,1:2000] #10 individuals in fourth location
freq_A <- freq(location_A)
freq_B <- freq(location_B)
freq_C <- freq(location_C)
freq_D <- freq(location_D)
freq <- function(data){
freq_1 <- c()
for (i in ncol(data)){
if (length(unique(data[ ,i]))==2){
freq_1 <- c(freq_1,(sum(data[ ,i]))/(nrow(data)))
}
}
#frequency_1 <- sum(freq_1)
return(freq_1)
}
freq_A <- freq(location_A)
freq_A
ncol(location_A)
freq_1 <- c()
for (i in ncol(location_A)){
if (length(unique(data[ ,i]))==2){
freq_1 <- c(freq_1,(sum(location_A[ ,i]))/(nrow(location_A)))
}
}
freq_1 <- c()
for (i in ncol(myData)){
if (length(unique(myData[ ,i]))==2){
freq_1 <- c(freq_1,(sum(myData[ ,i]))/(nrow(myData)))
}
}
freq_1
freq <- function(data){
freq_1 <- 0
for (j in nrow(data)){
for (i in ncol(data)){
if (data[j,i]))==1){
freq_1 <- freq_1 + 1
}
}
}
frequency_1 <- sum(freq_1)/nrow(data)
return(frequency_1)
}
freq_A <- freq(location_A)
freq <- function(data){
freq_1 <- 0
for (j in nrow(data)){
for (i in ncol(data)){
if (data[j,i]==1){
freq_1 <- freq_1 + 1
}
}
}
frequency_1 <- sum(freq_1)/nrow(data)
return(frequency_1)
}
freq_A <- freq(location_A)
freq_B <- freq(location_B)
freq_C <- freq(location_C)
freq_D <- freq(location_D)
freq_1 <- 0
freq <- function(data){
freq_1 <- 0
for (j in nrow(data)){
for (i in ncol(data)){
if (data[j,i]==1){
freq_1 <- freq_1 + 1
}
}
}
frequency_1 <- sum(freq_1)/nrow(data)
return(frequency_1)
}
freq_A <- freq(location_A)
location_A[1,1]
freq <- function(data){
freq_1 <- 0
for (j in 1:nrow(data)){
for (i in 1:ncol(data)){
if (data[j,i]==1){
freq_1 <- freq_1 + 1
}
}
}
frequency_1 <- sum(freq_1)/nrow(data)
return(frequency_1)
}
freq_A <- freq(location_A)
freq_B <- freq(location_B)
freq_C <- freq(location_C)
freq_D <- freq(location_D)
fst <- function(data1, data2){
# calculate frequencies
fA_1 <- apply(fun=sum, X=data1, mar=2)/nrow(data1)
fA_2 <- apply(fun=sum, X=data2, mar=2)/nrow(data2)
return(fA_1,fA_2)
}
fst(location_A,location_B)
fst <- function(data1, data2){
# calculate frequencies
fA_1 <- apply(FUN=sum, X=data1, MAR=2)/nrow(data1)
fA_2 <- apply(FUN=sum, X=data2, MAR=2)/nrow(data2)
return(fA_1,fA_2)
}
fst(location_A,location_B)
fst <- function(data1, data2){
# calculate frequencies
fA_1 <- as.numeric(apply(FUN=sum, X=data1, MAR=2)/nrow(data1))
fA_2 <- as.numeric(apply(FUN=sum, X=data2, MAR=2)/nrow(data2))
return(fA_1,fA_2)
}
fst(location_A,location_B)
fA_1
fst <- function(data1){
# calculate frequencies
fA_1 <- as.numeric(apply(FUN=sum, X=data1, MAR=2)/nrow(data1))
#fA_2 <- as.numeric(apply(FUN=sum, X=data2, MAR=2)/nrow(data2))
return(fA_1)
}
fst(location_A)
fst <- function(data1 data2){
# calculate frequencies
fA_1 <- as.numeric(apply(FUN=sum, X=data1, MAR=2)/nrow(data1))
fA_2 <- as.numeric(apply(FUN=sum, X=data2, MAR=2)/nrow(data2))
return(fA_1)
}
fst <- function(data1, data2){
# calculate frequencies
fA_1 <- as.numeric(apply(FUN=sum, X=data1, MAR=2)/nrow(data1))
fA_2 <- as.numeric(apply(FUN=sum, X=data2, MAR=2)/nrow(data2))
return(fA_1)
}
fst(location_A, location_B)
fst <- function(data1, data2){
# calculate frequencies
fA_1 <- as.numeric(apply(FUN=sum, X=data1, MAR=2)/nrow(data1))
fA_2 <- as.numeric(apply(FUN=sum, X=data2, MAR=2)/nrow(data2))
return(fA_1, fA_2)
}
fst(location_A, location_B)
fst <- function(data1, data2){
# calculate frequencies
fA_1 <- as.numeric(apply(FUN=sum, X=data1, MAR=2)/nrow(data1))
fA_2 <- as.numeric(apply(FUN=sum, X=data2, MAR=2)/nrow(data2))
return(c(fA_1, fA_2))
}
fst(location_A, location_B)
length(fA_1)
fA_1
fst <- function(data1, data2){
# calculate frequencies
fA_1 <- as.numeric(apply(FUN=sum, X=data1, MAR=2)/nrow(data1))
fA_2 <- as.numeric(apply(FUN=sum, X=data2, MAR=2)/nrow(data2))
return(c(fA_1, fA_2))
}
fst(location_A, location_B)
fA_1
fst <- function(data1, data2){
# calculate frequencies
fA_1 <- as.numeric(apply(FUN=sum, X=data1, MAR=2)/nrow(data1))
fA_2 <- as.numeric(apply(FUN=sum, X=data2, MAR=2)/nrow(data2))
A <- fA_1
B <- fA_2
# calculate HT
HT <- 2
return(c(fA_1, fA_2))
}
fst(location_A, location_B)
A
fst <- function(data1, data2){
# calculate frequencies
fA_1 <- as.numeric(apply(FUN=sum, X=data1, MAR=2)/nrow(data1))
fA_2 <- as.numeric(apply(FUN=sum, X=data2, MAR=2)/nrow(data2))
# calculate HT
HT <- 2*((fA_1+fA_2)/2)*(1-((fA_1+fA_2)/2))
return(HT)
}
fst(location_A, location_B)
fst <- function(data1, data2){
# calculate frequencies
fA_1 <- as.numeric(apply(FUN=sum, X=data1, MAR=2)/nrow(data1))
fA_2 <- as.numeric(apply(FUN=sum, X=data2, MAR=2)/nrow(data2))
# calculate Ht
HT <- 2*((fA_1+fA_2)/2)*(1-((fA_1+fA_2)/2))
# calculate Hs
HS <- (fA_1*(1-fA_1)) + (fA_2*(1-fA_2))
# calculate FST
FST <- (HT-HS)/HT
return(FST)
}
fst(location_A, location_B)
fst <- function(data1, data2){
# calculate frequencies
fA_1 <- as.numeric(apply(FUN=sum, X=data1, MAR=2)/nrow(data1))
fA_2 <- as.numeric(apply(FUN=sum, X=data2, MAR=2)/nrow(data2))
# calculate Ht
HT <- 2*((fA_1+fA_2)/2)*(1-((fA_1+fA_2)/2))
# calculate Hs
HS <- (fA_1*(1-fA_1)) + (fA_2*(1-fA_2))
# calculate FST
FST <- (HT-HS)/HT
# average FST
FST <- FST[!is.na(FST)]
avg_fst <- mean(FST)
return(avg_fst)
}
fst(location_A, location_B)
distance <- dist(myData)
tree <- hclust(distance)
plot(tree, labels=locations)
locations <- rep(c("A","B","C","D"), each=10)
plot(tree, labels=locations)
distance
tree
plot(tree, labels=locations)
plot(tree)
plot(tree, labels(locations))
myGenotypeData <- as.matrix(read.csv("genomics_and_bioinformatics/Practicals/turtle.genotypes.csv", header=FALSE, stringsAsFactors = FALSE, colClasses = c("numeric", len)))
len <- 2000
myGenotypeData <- as.matrix(read.csv("genomics_and_bioinformatics/Practicals/turtle.genotypes.csv", header=FALSE, stringsAsFactors = FALSE, colClasses = c("numeric", len)))
data <- as.matrix(read.csv("../turtle.genotypes.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
data <- as.matrix(read.csv("genomics_and_bioinformatics/Practicals/turtle.genotypes.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
distance <- dist(Data)
distance <- dist(data)
distance
locations <- rep(c("A","B","C","D"), each=10)
tree <- hclust(distance)
plot(tree, labels(locations))
plot(tree, labels=locations)
A_v_B <- fst(location_A,location_B)
A_v_B
AvB <- fst(location_A,location_B)
print(AvB)
AvC <- fst(location_A,location_C)
print(AvC)
AvD <- fst(location_A,location_D)
print(AvD)
BvC <- fst(location_B,location_C)
print(BvC)
BvD <- fst(location_B,location_D)
print(BvD)
CvD <- fst(location_C,location_D)
print(CvD)
ab <- 5
ac <- 7
ad <- 45
bc <- 2
bd <- 40
cd <- 38
y <- c(AvB,AvC,AvD,BvC,BvD,CvD)
y
x <- c(ab,ac,ad,bc,bd,cd)
plot(x,y, main="Correlation")
plot(x,y, main="Average FST for Location Comparisons")
len <- 2000
data <- as.matrix(read.csv("genomics_and_bioinformatics/Practicals/turtle.genotypes.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric", len)))
locations <- rep(c("A","B","C","D"), each=10)
distance <- dist(data)
tree <- hclust(distance)
plot(tree, labels=locations)
